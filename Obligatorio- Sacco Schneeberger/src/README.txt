Para hacer la primera consulta: Para hacer la primera consulta, primero debemos extraer del archivo drivers.txt a los pilotos. También hay que pedirle la fecha consultada al usuario. Estas dos se hacen con un scanner. Luego pasamos estos datos como parámetros a la clase de la consulta hecha, se procesan los tweets y se filtran a partir de su fecha, y luego se revisa si el texto contiene escrito el apellido de algún corredor. En caso que se menciona un piloto, a aquel piloto se le sumará una mención (la cual es un atributo). Luego se colocan a todos los pilotos dentro de un árbol y se agarra al nodo que está más a la derecha (el nodo con mayor key), se agrega a una LinkedList y se elimina. Este último proceso se hace 10 veces. Se hace print luego de estos 10 corredores, en orden.

Para hacer segunda consulta: A través del procesado de tweets, utilizaremos solo los headers “user_name” y “user_verified”. A cada nuevo usuario, crearemos el objeto User con una cantidad de tweets igual a 1 (la cual es un atributo del objeto) y lo agregamos a un hash con clave en “user_name”. Si el nombre de usuario ya existe en el hash, se hace un find y luego se le suma 1 a la cantidad de tweets. Al final, se agregan todos los usuarios a un BST, se consigue al nodo mas a la derecha, se agrega a una LinkedList y se elimina del árbol. Este último proceso se repite 15 veces.

Para hacer la tercera consulta: primeramente se le pide al usuario una fecha. Al procesar los tweets, se filtraran por su fecha, y luego se suma a un counter si aparece un hashtag nuevo. Para saber si hay un hashtag nuevo, primero debemos separar al dato “hashtags”, la cual viene con el formato [“#hashtag1”, “#hashtag2”], en strings distintos, sin ningún elemento aparte de lo que esta dentro de las comillas. Luego, se comprueba que estos hashtags sean nuevos, utilizando un hash con hashtags ya registrados. Al final, se imprime el counter.

Para hacer la cuarta consulta: primero se le pide al usuarios que ingrese una fecha. Luego, se filtran los tweets a través de si fueron escritos en esta misma fecha. Para cada hashtag en el tweet, se fija en un hash de hashtags registrados si ya fue ingresado. Si no fue ingresado, se crea el objeto Hashtag (el cual tiene un counter de usos) y se le asigna el valor 1 a cantidad de usos, y se lo agrega al hash anterior. Si existe, simplemente se le aumenta la cantidad de usos por 1. Por último, se ingresan todos los Hashtags a un BST y se imprime como resultado el nodo más a la derecha del árbol.
                           
Para hacer la quinta consulta: Del procesado de tweets , obtenemos los headers “user_name” y “user_favourites”. Si el usuario se encuentra dentro del hash de usuarios registrados (con key en “user_name) y se le suma a su cantidad de favoritos totales el valor de “user_favourites”. Si no se encuentra, creamos una nueva instancia de la clase User con su contador de favoritos de valor “user_favourites” y lo agregamos al hash’. Por último, ordenamos el hash, insertando los usuarios en un BST en el que la clave de ordenamiento es su cantidad de favoritos, se consigue al nodo más a la derecha, se agrega a una LinkedList y se elimina del árbol. Este último proceso se repite 7 veces.
                      
Para hacer la sexta consulta: Primero se le pide al usuario una palabra o frase al usuario. Del procesado de tweets nos quedamos únicamente con el header “texto”, y utilizamos la función .equals() para ver si el tweet contiene lo insertado por el usuario. Esta función tiene un atributo counter, el cual empieza en 0 y se le suma 1 cada vez que la función .equals() nos de true.



CONSIDERACIONES:
	-Se utiliza toLowerCase() en todas las funciones, para poder generalizar entre strings como "#f1" y "#F1".
	-En la primera consulta, solo se busca que se mencione el apellido, sin incluir el nombre. Esto es debido a que, por ejemplo, se podria encontrar el texto "@max_fernandez ..." y esto contaria como una mencion indeseada.
	-En la segunda consulta, los usuarios aparecen verificados con un 'signo de tick'
	-En la cuarta consulta, ademas de no tener en cuenta el hashtag #f1, tampoco se consideran #F1, ni #formula1 ni #Formula1.
	-En la quinta consulta, se considera a la columna 'user_favourites' del archivo CSV como la cantidad de favourites que recibio el tweet del registro. El resultado es la suma de todos los 'user_favourites'.
	-En la sexta consulta, al igual que la primera consideracion, se utiliza toLowerCase() a la palabra/frase ingresada por el usuario.